//********************************************************************
//*                       Звонок 64 мелодии                          *
//*                      (C)  В.Пушков, 2016                         *
//*                   Версия 1.0 от 22.09.2016                       *
//*                   Версия 1.1 от 01.11.2016  (PB0)                *
//*                   Версия 2.0 от 03.11.2016  (Обмен с EEPROM)     *
//*                   AVR Studio V4.19 Build 730                     *
//********************************************************************
//Данная разработка представляет собой адаптацию под МК ATtiny2313
//оригинальной схемы на ТТЛ-логике, автор которой неизвестен
//********************************************************************
//Частота МК от кварцевого генератора: 8 МГц
//Low Fuse:  DE
//High Fuse: DB
//PD0 - сигнал SCL к микросхеме EEPROM (2K) AT24C16
//PD1 - сигнал SDA к микросхеме EEPROM (2K) AT24C16
//PD2 - контакт кнопки (замыкание на общий провод)
//PD6 - перемычка режима случайного выбора мелодии
//(при снятой перемычке - режим последовательного перебора мелодий)
//PB0 - сигнализирует о проигрывании мелодии высоким уровнем
//Тональный сигнал для нот формируется с помощью канала A таймера 1,
//работающего в режиме совпадения по сравнению. Для формирования
//строба эффекта "вибрато" используется канал B этого же таймера.
//Таймер 0 используется для генерации случайного номера мелодии.


#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>

#define nm 64 //Количество генерируемых мелодий
#define m_len 32 //Количество управляющих кодов в каждой мелодии
unsigned char buf [m_len]; //Буфер для кодов мелодии

#define CLK_HZ 8000000ul //Тактовая частота МК
#define T1_PS 8    //Коэффициент предделителя таймера 1
#define T1A_1 CLK_HZ/(2 * T1_PS) //Число тиков канала A таймера 1 для полупериода частоты 1 Гц
const unsigned int T1_G  = T1A_1/392; //Число тиков таймера 1 для полупериода частоты ноты Соль
const unsigned int T1_G_ = T1A_1/415; //Число тиков таймера 1 для полупериода частоты ноты Соль-диез 
const unsigned int T1_A  = T1A_1/440; //Число тиков таймера 1 для полупериода частоты ноты Ля 
const unsigned int T1_A_ = T1A_1/466; //Число тиков таймера 1 для полупериода частоты ноты Ля-диез 
const unsigned int T1_B  = T1A_1/494; //Число тиков таймера 1 для полупериода частоты ноты Си 
const unsigned int T1_C  = T1A_1/523; //Число тиков таймера 1 для полупериода частоты ноты До 
const unsigned int T1_C_ = T1A_1/554; //Число тиков таймера 1 для полупериода частоты ноты До-диез 
const unsigned int T1_D  = T1A_1/587; //Число тиков таймера 1 для полупериода частоты ноты Ре 
const unsigned int T1_D_ = T1A_1/622; //Число тиков таймера 1 для полупериода частоты ноты Ре-диез
const unsigned int T1_E  = T1A_1/659; //Число тиков таймера 1 для полупериода частоты ноты Ми 
const unsigned int T1_F  = T1A_1/698; //Число тиков таймера 1 для полупериода частоты ноты Фа 
const unsigned int T1_F_ = T1A_1/740; //Число тиков таймера 1 для полупериода частоты ноты Фа-диез 

//#define T0_PS 1024 //Коэффициент предделителя таймера 0
#define vibr_strobe 120 //Длительность строба "вибрато", мкс 
#define vibr_period 50  //Период повторения стробов "вибрато", мс
//Число тиков канала B таймера 1 для длительности строба "вибрато"
const unsigned int T1B_0 = (CLK_HZ/1000000ul)*vibr_strobe/T1_PS;
//Число тиков канала B таймера 1 при отсутствии строба "вибрато"
const unsigned int T1B_1 = (CLK_HZ/1000000ul)*(vibr_period*1000ul-vibr_strobe)/T1_PS;
#define temp0 400  //Длительность такта мелодии при медленном темпе, мс
#define temp1 250  //Длительность такта мелодии при быстром темпе, мс

volatile unsigned char flag_t; //Флаг темпа воспроизведения ноты: 1 - быстрее, 0 - медленнее
volatile unsigned char flag_o; //Флаг октавы ноты: 1 - на октаву вверх (2*f)
volatile unsigned char flag_v; //Флаг вибрато: 1 - с вибрато, 0 - без вибрато
volatile unsigned char m; //Номер мелодии 0..63
volatile unsigned char n; //Номер ноты 0..31 (коэффициент деления для счётчика ИЕ8 в ориг. схеме)
volatile unsigned int n1; //Константа полупериода тона ноты для регистра сравнения таймера 1
volatile unsigned char pause = 0;    //Признак генерации паузы
volatile unsigned char strobe = 0;   //Признак действия строба "вибрато"


//=== Обработка входных сигналов

unsigned char check_jmp (void)
//Проверка, замкнута ли перемычка случайного выбора мелодии
{
return (!(PIND & (1 << PD6)));
}


unsigned char check_pressed (void)
//Проверка, нажата ли кнопка звонка
{
return (!(PIND & (1 << PD2)));
}


unsigned char safe_check_pressed (void)
//Проверка нажатия кнопки звонка с антидребезгом
{
unsigned char cycle = 5; //Число опросов нажатия кнопки
while ((check_pressed()) && cycle)
  {
  _delay_ms(10); //Задержка
  cycle--;
  }
return (cycle==0);
}


//=== Блок работы с EEPROM по шине I2C
//Состояние вывода SDA по умолчанию - вход МК с высоким уровнем

//Распределение портов шины I2C для микросхемы памяти
#define SCL_PORT     PORTD
#define SCL_PORTD    DDRD
#define SDA_PORT     PORTD
#define SDA_PORTD    DDRD
#define SCL_PORT_INP PIND
#define SDA_PORT_INP PIND
#define SCL	0
#define SDA	1
#define USI_DELAY 5  //Задержка для обмена по шине I2C, мкс


void set_scl (void)
//Установка шины SCL в состояние высокого уровня
{
SCL_PORTD |= (1 << SCL); //Выход SCL
SCL_PORT  |= (1 << SCL);
}


void clr_scl (void)
//Установка шины SDA в состояние низкого уровня
{
SCL_PORTD |= (1 << SCL); //Выход SCL
SCL_PORT  &= ~(1 << SCL);
}


void set_sda (void)
//Установка шины SDA в состояние высокого уровня
{
SDA_PORTD |= (1 << SDA); //Выход SDA
SDA_PORT  |= (1 << SDA);
}


void clr_sda (void)
//Установка шины SDA в состояние низкого уровня
{
SDA_PORTD |= (1 << SDA); //Выход SDA
SDA_PORT  &= ~(1 << SDA);
}


void in_sda (void)
//Перевод сигнала SDA в состояние входа МК
{
SDA_PORTD &= ~(1 << SDA); //Вход SDA
SDA_PORT  |= (1 << SDA);  //Подтягивающий резистор для SDA
}


unsigned char get_sda (void)
//Чтение состояния сигнала SDA (предполагается, что SDA в режиме входа)
{
//in_sda ();
unsigned char b = (SDA_PORT_INP & (1 << SDA)) >> SDA;  //0 или 1
return (b);
}


void mem_delay (void)
//Формирование задержки для доступа к памяти по шине I2C
{
_delay_us (USI_DELAY);
}


void mem_start (void)
//Формирование состояния Старт
{
set_sda ();
mem_delay ();
set_scl ();
mem_delay ();
clr_sda ();
mem_delay ();
clr_scl ();
mem_delay ();
in_sda ();
}


void mem_stop (void)
//Формирование состояния Стоп
{
clr_sda ();
mem_delay ();
set_scl ();
mem_delay ();
set_sda ();
mem_delay ();
in_sda ();
}


void mem_ack (void)
//unsigned char mem_ack (void) //0 - нет подтверждения, иначе - есть
//Подтверждение от памяти
{
mem_delay ();
set_sda ();
mem_delay ();
in_sda ();
set_scl ();
unsigned char c = 1; //Признак цикла опроса ACK
unsigned char i = 4; //Счётчик циклов опроса ACK
while ((i>0) && (c > 0)) //Цикл опроса ACK
  {
  i--;
  mem_delay ();
  c = get_sda (); //c = 0 - получено подтверждение ACK, c = 1 - не получено
  }
clr_scl ();
mem_delay ();
mem_delay ();
//return((c==0));
}


void mem_wb (unsigned char wb)
//Запись байта в шину обмена с памятью
{
for (unsigned char i=0; i<8; i++)
  {
  if ((wb & (0x80 >> i)) == 0)
     clr_sda ();
  else
     set_sda ();
  mem_delay ();  
  set_scl ();
  mem_delay ();
  clr_scl ();
  mem_delay ();
  }
in_sda ();
}


unsigned char mem_rb (void)
//Чтение байта из шины обмена с памятью
{
unsigned char data = 0;
set_sda ();
in_sda ();
for (unsigned char i=0; i<8; i++)
  {
  set_scl ();
  mem_delay ();  
  mem_delay ();  
  data = (data << 1) | get_sda ();
  clr_scl ();
  mem_delay ();  
  mem_delay ();
  }
return (data);
}


/*
void mem_write (unsigned int adr, unsigned char wb)
//Запись байта в память - не проверялась и здесь не используется
{
mem_start ();
unsigned char adrL = adr & 0xFF;
unsigned char adrH = (((adr >> 8) << 1) & (0x0E)) | 0xA0;
mem_wb (adrH);
mem_ack ();
mem_wb (adrL);
mem_ack ();
mem_wb (wb);
mem_ack ();
mem_stop ();
_delay_ms (1); ?
}
*/


unsigned char mem_read (unsigned int adr)
//Чтение байта из памяти
{
mem_start ();
unsigned char adrL = adr & 0xFF;
unsigned char adrH = (((adr >> 8) << 1) & (0x0E)) | 0xA0;
mem_wb (adrH);
mem_ack ();
mem_wb (adrL);
mem_ack ();
mem_delay ();
mem_stop ();
mem_delay ();
mem_start ();
adrH = (((adr >> 8) << 1) & (0x0E)) | 0xA0 | 0x01;
mem_wb (adrH);
mem_ack ();
mem_delay ();
unsigned char b = mem_rb ();
mem_ack ();
mem_stop ();
return (b);
}


//=== Обработка кодов мелодии

void mem_read_buf (unsigned int adr, unsigned char buf[])
//Чтение m_len байтов из памяти в буфер
{
for (unsigned char i=0; i<m_len; i++)
  buf[i] = mem_read (adr + i);
}


unsigned char random_m (void)
//Генерация случайного номера мелодии
{
return (TCNT0 & 0x3F); //Случайное число из счётчика таймера 0
}


unsigned int melody_addr (unsigned char m)
//Вычисление адреса памяти 0..(2K-1) по номеру мелодии m=0..63
{
return ((m & 0x3F) << 5); //m * 32
}


void parse_code (unsigned char code)
//Анализ кода ноты code из массива мелодии и определение параметров:
//flag_t - флаг темпа, flag_o - флаг октавы, flag_v - флаг вибрато, n - номер ноты
{
flag_t = (code & 0x80);
flag_o = (code & 0x40);
flag_v = (code & 0x20);
n = code & 0x1F;
}


unsigned int tone_code (unsigned char flag_o, unsigned char n)
//Определение кода тона ноты для загрузки в регистр совпадения A таймера 1
//Частота на входе таймера 1 (с учётом предделителя) - 1 МГц
//Входные параметры:
//flag_o - флаг верхней октавы
//n - номер ноты
//Если возвращаемое значение 0, то формировать паузу
{
volatile unsigned long k = 0; //Результат
if ((n & 0x07) != 0x07)
   //Не пауза
   switch (n)
   {
	 case 0: //Соль
	   k = T1_G;
	   break;
	 case 2: //Соль#
	   k = T1_G_; 
	   break;
	 case 4: //Ля
	   k = T1_A; 
	   break;
	 case 6: //Ля#
	   k = T1_A_; 
	   break;
	 case 8: //Си
	   k = T1_B; 
	   break;
	 case 9: //Си - тоже используется
	   k = T1_B; 
	   break;
	 case 11: //До
	   k = T1_C; 
	   break;
	 case 13: //До#
	   k = T1_C_; 
	   break;
	 case 16: //Ре
	   k = T1_D; 
	   break;
	 case 19: //Ре#
	   k = T1_D_; 
	   break;
	 case 22: //Ми
	   k = T1_E; 
	   break;
	 case 25: //Фа
	   k = T1_F; 
	   break;
	 case 28: //Фа#
	   k = T1_F_; 
	   break;
     default: //Несуществующая нота
	   k = 0;
   } //switch
   if ((flag_o) && (k > 0)) 
      k = (k >> 1); //На октаву вверх: длительность уменьшить в два раза
return (k);
}


void play (unsigned char buf[])
//Перебор управляющих кодов мелодии в буфере buf и их воспроизведение
{
unsigned char i = 0; //Счётчик кодов мелодии
while (i < m_len)
  {
  parse_code (buf [i]); //Получить и обработать очередной код мелодии -> flag_t,flag_o,flag_v,n
  //Определение длины серии подряд идущих одинаковых кодов нот
  unsigned char s = 1; //Счётчик длины серии
  unsigned char j = i+1; //Номер следующей ноты
  while (j < m_len)
    {
	if (buf [i] == buf [j]) //Продолжение серии
	   { s++; j++; i++; }
    else
	   j = m_len; //Конец серии
	} 
  //Здесь s - число одинаковых подряд идущих кодов нот
  n1 = tone_code (flag_o,n); //Вычисление константы полупериода ноты для таймера 1
  //Подготовка к генерации тона ноты
  pause = 1;
  if (n1 > 0) //Нота, иначе - пауза (и ничего не генерировать)
     {
	 pause = 0;  //Нота, не пауза
	 strobe = 0; //Нет строба "вибрато"
     TCCR1B = 0; //Останов таймера 1
	 TCNT1 = 0;  //Обнулить счётчик таймера 1
     OCR1A = n1; //Записать константу в регистр сравнения A таймера 1
     TCCR1A =  (1 << COM1A0); //Включить смену уровней при сравнении A таймера 1; Normal mode
     TIMSK &= ~(1 << OCIE1B); //Запретить прерывания по совпадению B таймера 1
	 //Включение режима "вибрато", если задан
	 if (flag_v)
	    {
		OCR1B = T1B_1;
        TIMSK  |= (1 << OCIE1B); //Разрешить прерывания по совпадению B таймера 1
		}
     TCCR1B |= (1 << CS11); //Пуск таймера 1 с предделителем 8
     TIMSK  |= (1 << OCIE1A);  //Разрешить прерывания по совпадению A таймера 1
	 //Во время интервала, формируемого следующими ниже процедурами
	 //временной задержки, будет разрешена генерация тона ноты
	 }
  //Формирование общей длительности для серии одинаковых нот
  for (j=0;j<s;j++)
    {
    if (flag_t)
       _delay_ms (temp1); //Длительность ноты для быстрого темпа
    else
       _delay_ms (temp0); //Длительность ноты для медленного темпа
	}
  //Завершение генерации текущей ноты
  TIMSK &= ~(1 << OCIE1A); //Запретить прерывания по совпадению A таймера 1
  TIMSK &= ~(1 << OCIE1B); //Запретить прерывания по совпадению B таймера 1
  TCCR1B = 0; //Останов таймера 1
  TCCR1A = 0; //Отключить выход PB3 от таймера 1
  PORTB &= ~(1 << PB3); //Нулевой уровень на выходе PB3
  i++;
  }
}


ISR (TIMER1_COMPA_vect)
//=== Обработчик прерывания по совпадению A при сравнении таймера/счётчика 1
//    для управления выходным тоном
//Принцип формирования тонального сигнала описан в http://alex.starspirals.net
{
//Задать следующий полупериод
OCR1A += n1;
}


ISR (TIMER1_COMPB_vect)
//=== Обработчик прерывания по совпадению B при сравнении таймера/счётчика 1
//    для формирования стробов "вибрато"
{
if (pause == 0) //Идёт процесс формирования ноты (не пауза)
   {
   if (strobe) //Звук сейчас заблокирован стробом
      {
	  strobe = 0;    //Отключить строб, возобновить звук 
	  TCCR1B = 0;    //Остановить таймер 1
	  TCNT1 = 0;     //Обнулить таймер 1
	  TCCR1A = (1 << COM1A0); //Включить смену уровней при сравнении A таймера 1; Normal mode
	  OCR1A = n1;    //Инициализировать длительность полупериода для тона ноты
	  OCR1B = T1B_1; //Занести в регистр сравнения B таймера 1 длительность отсутствия строба
	  TCCR1B |= (1 << CS11);   //Запустить таймер 1
      TIMSK  |= (1 << OCIE1A); //Разрешить прерывания по совпадению A таймера 1
	  }
   else //Звук сейчас выводится
      {
	  strobe = 1; //Включить строб, заблокировать звук 
	  TCCR1B = 0; //Остановить таймер 1
	  TCNT1 = 0;  //Обнулить таймер 1
      //TCCR1A = 0; //Отключить выход PB3 от таймера 1
      //PORTB &= ~(1 << PB3); //Нулевой уровень на выходе PB3
	  OCR1B = T1B_0; //Занести в регистр сравнения B таймера 1 длительность строба
	  TCCR1B |= (1 << CS11);    //Запустить таймер 1
      TIMSK  &= ~(1 << OCIE1A); //Запретить прерывания по совпадению A таймера 1
	  } 
   }  
}


/*
ISR (INT0_vect)
//=== Обработчик внешнего прерывания INT0 по нажатию кнопки
{
...
EIFR  |= (1 << INTF0);//Сбрасываем флаг прерывания INT0 установкой его в 1
GIMSK |= (1 << INT0); //Разрешаем прерывания по входу INT0
}
*/


ISR (WDT_OVERFLOW_vect)
//=== Обработчик прерывания от сторожевого таймера
{
wdt_reset (); //Сброс сторожевого таймера
WDTCSR |= (1 << WDIE); //Разрешение прерываний по сторожевому таймеру
//TCNT0 = 0; //Вносим дополнительный элемент случайности в датчик случайных чисел 
}



//========================================================
int main (void)
{

//Настройка входов и выходов
DDRD &= ~((1 << PD2) | (1 << PD6)); //Входные сигналы 
PORTD |= (1 << PD2) | (1 << PD6);   //Включить для них подтягивающие резисторы
DDRB  |= ((1 << PB0) | (1 << PB3)); //Подключить PB3, PB0 как выходы
PORTB &= ~(1 << PB0); //PB0 -> 0
//Настройка прерываний и таймеров
TCCR1B = 0; //Останов таймера 1
TCCR1A = 0; //Отключить выход PB3 от таймера 1
PORTB &= ~(1 << PB3); //Нулевой уровень на выходе PB3
TCNT1 = 0;
TIMSK &= ~(1 << OCIE1A); //Запретить прерывания по совпадению A таймера 1
TIMSK &= ~(1 << OCIE1B); //Запретить прерывания по совпадению B таймера 1
TCCR0B = 0; //Останов таймера 0
TCCR0A = 0; //Normal mode для таймера 0
TCCR0B = (1 << CS02) | (1 << CS00); //Пуск таймера 0 с предделителем 1024 (частота 7.8125 кГц)
//TCCR0B = (1 << CS01); //Пуск таймера 0 с предделителем 8 (частота 1 МГц)
//При нажатии кнопки звонка значение счётчика T0 будет содержать случайное число
//MCUCR |= ~((1 << ISC01) | (1 << ISC00));  //Прерывание INT0 - по спаду 
//GIMSK |= ((1 << INT0));   //Разрешаем прерывание INT0
//EIFR  |= ((1 << INTF0)); //Сбрасываем флаг прерывания INT0
wdt_enable (WDTO_250MS); //Включить сторожевой таймер
WDTCSR |= (1 << WDIE); //Разрешить прерывания от сторожевого таймера

_delay_ms (500); //Ждём окончание переходных процессов
while (check_pressed ()); //Ждать, если нажата кнопка
sei (); //Глобально разрешить прерывания

m = 0; //Начальный код мелодии для режима последовательного перебора
while (1) //
{

//Проверка нажатия кнопки звонка
if (safe_check_pressed ())
   {
   //Проверяем, установлена ли перемычка случайного выбора мелодии
   if (check_jmp ())
      m = random_m (); //Сгенерировать случайный номер мелодии
   if (m >= nm) 
      m = 0; //Начать с начала
   //Загрузка управляющей строки мелодии из внешней памяти в буфер
   mem_read_buf (melody_addr (m), buf); 
   //Генерация мелодии по кодам, загруженным в буфер
   PORTB |= (1 << PB0); //PB0 -> 1
   play (buf);
   PORTB &= ~(1 << PB0); //PB0 -> 0
   //Конец обработки мелодии
   while (check_pressed ()); //Ждать, пока не будет отпущена кнопка
   _delay_ms (500); //Пауза перед проверкой следующего нажатия кнопки
   m++; //Увеличить номер мелодии (для последовательного перебора)
   } //Завершение обработки нажатия кнопки звонка

} //while (1)

}


